// Code generated by MockGen. DO NOT EDIT.
// Source: vendor/github.com/aws/aws-sdk-go/service/s3/s3manager/s3manageriface/interface.go

// Package mocks is a generated GoMock package.
package mocks

import (
	aws "github.com/aws/aws-sdk-go/aws"
	s3 "github.com/aws/aws-sdk-go/service/s3"
	s3manager "github.com/aws/aws-sdk-go/service/s3/s3manager"
	gomock "github.com/golang/mock/gomock"
	io "io"
	reflect "reflect"
)

// MockDownloaderAPI is a mock of DownloaderAPI interface
type MockDownloaderAPI struct {
	ctrl     *gomock.Controller
	recorder *MockDownloaderAPIMockRecorder
}

// MockDownloaderAPIMockRecorder is the mock recorder for MockDownloaderAPI
type MockDownloaderAPIMockRecorder struct {
	mock *MockDownloaderAPI
}

// NewMockDownloaderAPI creates a new mock instance
func NewMockDownloaderAPI(ctrl *gomock.Controller) *MockDownloaderAPI {
	mock := &MockDownloaderAPI{ctrl: ctrl}
	mock.recorder = &MockDownloaderAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDownloaderAPI) EXPECT() *MockDownloaderAPIMockRecorder {
	return m.recorder
}

// Download mocks base method
func (m *MockDownloaderAPI) Download(arg0 io.WriterAt, arg1 *s3.GetObjectInput, arg2 ...func(*s3manager.Downloader)) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Download", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Download indicates an expected call of Download
func (mr *MockDownloaderAPIMockRecorder) Download(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Download", reflect.TypeOf((*MockDownloaderAPI)(nil).Download), varargs...)
}

// DownloadWithContext mocks base method
func (m *MockDownloaderAPI) DownloadWithContext(arg0 aws.Context, arg1 io.WriterAt, arg2 *s3.GetObjectInput, arg3 ...func(*s3manager.Downloader)) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DownloadWithContext", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DownloadWithContext indicates an expected call of DownloadWithContext
func (mr *MockDownloaderAPIMockRecorder) DownloadWithContext(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownloadWithContext", reflect.TypeOf((*MockDownloaderAPI)(nil).DownloadWithContext), varargs...)
}

// MockDownloadWithIterator is a mock of DownloadWithIterator interface
type MockDownloadWithIterator struct {
	ctrl     *gomock.Controller
	recorder *MockDownloadWithIteratorMockRecorder
}

// MockDownloadWithIteratorMockRecorder is the mock recorder for MockDownloadWithIterator
type MockDownloadWithIteratorMockRecorder struct {
	mock *MockDownloadWithIterator
}

// NewMockDownloadWithIterator creates a new mock instance
func NewMockDownloadWithIterator(ctrl *gomock.Controller) *MockDownloadWithIterator {
	mock := &MockDownloadWithIterator{ctrl: ctrl}
	mock.recorder = &MockDownloadWithIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDownloadWithIterator) EXPECT() *MockDownloadWithIteratorMockRecorder {
	return m.recorder
}

// DownloadWithIterator mocks base method
func (m *MockDownloadWithIterator) DownloadWithIterator(arg0 aws.Context, arg1 s3manager.BatchDownloadIterator, arg2 ...func(*s3manager.Downloader)) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DownloadWithIterator", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DownloadWithIterator indicates an expected call of DownloadWithIterator
func (mr *MockDownloadWithIteratorMockRecorder) DownloadWithIterator(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownloadWithIterator", reflect.TypeOf((*MockDownloadWithIterator)(nil).DownloadWithIterator), varargs...)
}

// MockUploaderAPI is a mock of UploaderAPI interface
type MockUploaderAPI struct {
	ctrl     *gomock.Controller
	recorder *MockUploaderAPIMockRecorder
}

// MockUploaderAPIMockRecorder is the mock recorder for MockUploaderAPI
type MockUploaderAPIMockRecorder struct {
	mock *MockUploaderAPI
}

// NewMockUploaderAPI creates a new mock instance
func NewMockUploaderAPI(ctrl *gomock.Controller) *MockUploaderAPI {
	mock := &MockUploaderAPI{ctrl: ctrl}
	mock.recorder = &MockUploaderAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockUploaderAPI) EXPECT() *MockUploaderAPIMockRecorder {
	return m.recorder
}

// Upload mocks base method
func (m *MockUploaderAPI) Upload(arg0 *s3manager.UploadInput, arg1 ...func(*s3manager.Uploader)) (*s3manager.UploadOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Upload", varargs...)
	ret0, _ := ret[0].(*s3manager.UploadOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Upload indicates an expected call of Upload
func (mr *MockUploaderAPIMockRecorder) Upload(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upload", reflect.TypeOf((*MockUploaderAPI)(nil).Upload), varargs...)
}

// UploadWithContext mocks base method
func (m *MockUploaderAPI) UploadWithContext(arg0 aws.Context, arg1 *s3manager.UploadInput, arg2 ...func(*s3manager.Uploader)) (*s3manager.UploadOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UploadWithContext", varargs...)
	ret0, _ := ret[0].(*s3manager.UploadOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UploadWithContext indicates an expected call of UploadWithContext
func (mr *MockUploaderAPIMockRecorder) UploadWithContext(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UploadWithContext", reflect.TypeOf((*MockUploaderAPI)(nil).UploadWithContext), varargs...)
}

// MockUploadWithIterator is a mock of UploadWithIterator interface
type MockUploadWithIterator struct {
	ctrl     *gomock.Controller
	recorder *MockUploadWithIteratorMockRecorder
}

// MockUploadWithIteratorMockRecorder is the mock recorder for MockUploadWithIterator
type MockUploadWithIteratorMockRecorder struct {
	mock *MockUploadWithIterator
}

// NewMockUploadWithIterator creates a new mock instance
func NewMockUploadWithIterator(ctrl *gomock.Controller) *MockUploadWithIterator {
	mock := &MockUploadWithIterator{ctrl: ctrl}
	mock.recorder = &MockUploadWithIteratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockUploadWithIterator) EXPECT() *MockUploadWithIteratorMockRecorder {
	return m.recorder
}

// UploadWithIterator mocks base method
func (m *MockUploadWithIterator) UploadWithIterator(arg0 aws.Context, arg1 s3manager.BatchUploadIterator, arg2 ...func(*s3manager.Uploader)) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UploadWithIterator", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UploadWithIterator indicates an expected call of UploadWithIterator
func (mr *MockUploadWithIteratorMockRecorder) UploadWithIterator(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UploadWithIterator", reflect.TypeOf((*MockUploadWithIterator)(nil).UploadWithIterator), varargs...)
}

// MockBatchDelete is a mock of BatchDelete interface
type MockBatchDelete struct {
	ctrl     *gomock.Controller
	recorder *MockBatchDeleteMockRecorder
}

// MockBatchDeleteMockRecorder is the mock recorder for MockBatchDelete
type MockBatchDeleteMockRecorder struct {
	mock *MockBatchDelete
}

// NewMockBatchDelete creates a new mock instance
func NewMockBatchDelete(ctrl *gomock.Controller) *MockBatchDelete {
	mock := &MockBatchDelete{ctrl: ctrl}
	mock.recorder = &MockBatchDeleteMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBatchDelete) EXPECT() *MockBatchDeleteMockRecorder {
	return m.recorder
}

// Delete mocks base method
func (m *MockBatchDelete) Delete(arg0 aws.Context, arg1 s3manager.BatchDeleteIterator) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete
func (mr *MockBatchDeleteMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockBatchDelete)(nil).Delete), arg0, arg1)
}
